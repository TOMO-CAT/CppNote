

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>10.9 并行和并发 &mdash; C++ Note v1.0 文档</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="10.10 固有的不可移植的特性" href="10.10%20%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7.html" />
    <link rel="prev" title="10.8 手动管理内存" href="10.8%20%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> C++ Note
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC1%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/index.html">第1章 变量与基本类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC2%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/index.html">第2章 语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC3%E7%AB%A0%20%E5%87%BD%E6%95%B0/index.html">第3章 函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC4%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6/index.html">第4章 运算符</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC5%E7%AB%A0%20%E7%B1%BB/index.html">第5章 类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC6%E7%AB%A0%20%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B/index.html">第6章 标准库类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC7%E7%AB%A0%20%E6%A8%A1%E6%9D%BF/index.html">第7章 模板</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC8%E7%AB%A0%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%A6%82%E5%BF%B5/index.html">第8章 关键字概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC9%E7%AB%A0%20%E7%AE%97%E6%B3%95/index.html">第9章 算法</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第10章 语法特性</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="10.1%20%E5%A4%B4%E6%96%87%E4%BB%B6.html">10.1 头文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.2%20%E5%9C%A8main%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E6%88%96%E4%B9%8B%E5%90%8E%E6%89%93%E5%8D%B0%E6%B6%88%E6%81%AF.html">10.2 在main函数之前或者之后打印消息</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.3%20%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC.html">10.3 左值与右值</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.4%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html">10.4 命名空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.5%20%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html">10.5 命名规范</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.6%20%E5%8F%98%E9%87%8F%E7%94%9F%E5%AD%98%E6%9C%9F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F.html">10.6 变量生存期和变量作用域</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.7%20%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%A8%A1%E6%9D%BF.html">10.7 标准类型转换模板</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.8%20%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98.html">10.8 手动管理内存</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10.9 并行和并发</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">并行基础</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">互斥量和临界区</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#std-mutex">1. std::mutex</a></li>
<li class="toctree-l4"><a class="reference internal" href="#std-recursive-mutex">2. std::recursive_mutex</a></li>
<li class="toctree-l4"><a class="reference internal" href="#std-timed-mutexstd-recursive-timed-mutex">3. 带超时的互斥量<code class="docutils literal notranslate"><span class="pre">std::timed_mutex</span></code>和<code class="docutils literal notranslate"><span class="pre">std::recursive_timed_mutex</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#future">期物Future</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">条件变量</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">1. 简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">2. 有互斥锁后还需要条件变量的原因</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">3. 实例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id8">原子操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">一致性模型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">1. 线性一致性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">2. 顺序一致性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">3. 因果一致性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">4. 最终一致性</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id14">内存顺序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">1. 简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">2. 内存顺序</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id17">内存模型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">1. 宽松模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">2. 释放/消费模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">3. 释放/获取模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">4. 顺序一致模型</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="10.10%20%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7.html">10.10 固有的不可移植的特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.11%20%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB.html">10.11 运行时类型识别</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.12%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html">10.12 异常处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.13%20%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.html">10.13 内存分布</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.14%20%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9.html">10.14 调试帮助</a></li>
<li class="toctree-l2"><a class="reference internal" href="10.15%20%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86.html">10.15 编译链接原理</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC11%E7%AB%A0%20C%2B%2B11%E6%96%B0%E6%A0%87%E5%87%86/index.html">第11章 C++11新标准</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">README</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">C++ Note</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第10章 语法特性</a> &raquo;</li>
        
      <li>10.9 并行和并发</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/docs/第10章 语言特性/10.9 并行和并发.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>10.9 并行和并发<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>并行基础<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">std::thread</span></code>用于创建一个执行的线程实例，它是一切并发编程的基础，使用时需要包含<code class="docutils literal notranslate"><span class="pre">&lt;thread&gt;</span></code>头文件，它提供了很多基本的线程操作，比如<code class="docutils literal notranslate"><span class="pre">get_id()</span></code>用于获取所创建线程的线程ID，使用<code class="docutils literal notranslate"><span class="pre">join()</span></code>来加入一个线程等。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">([]()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;tomocat&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>互斥量和临界区<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>C++11引入了<code class="docutils literal notranslate"><span class="pre">mutex</span></code>相关的类，其所有相关的函数都放在<code class="docutils literal notranslate"><span class="pre">&lt;mutex&gt;</span></code>头文件中。<code class="docutils literal notranslate"><span class="pre">std::mutex</span></code>是C++11中最基本的<code class="docutils literal notranslate"><span class="pre">mutex</span></code>类，通过实例化<code class="docutils literal notranslate"><span class="pre">std::mutex</span></code>可以创建互斥量，而通过其成员函数<code class="docutils literal notranslate"><span class="pre">lock()</span></code>可以进行上锁，<code class="docutils literal notranslate"><span class="pre">unlock()</span></code>可以进行解锁。在实际编写代码的过程中，最好不要去直接调用成员函数，因为需要在每个临界区的出口处（以及任何可能抛出异常的地方）调用<code class="docutils literal notranslate"><span class="pre">unlock()</span></code>。C++11为互斥量提供了一个RAII语法的模板类<code class="docutils literal notranslate"><span class="pre">std::lock_guard</span></code>，可以在确保代码整洁性的同时保证代码的异常安全性。</p>
<p>在RAII语法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">critical_section</span><span class="p">(</span><span class="kt">int</span> <span class="n">change_v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>

    <span class="c1">// 执行竞争操作</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">change_v</span><span class="p">;</span>

    <span class="c1">// 离开作用域后mtx会被释放</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">critical_section</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">t2</span><span class="p">(</span><span class="n">critical_section</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;v:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>由于C++保证了所有栈对象在声明周期结束时会被销毁，所以这样的代码也是异常安全的。无论<code class="docutils literal notranslate"><span class="pre">critical_section</span></code>正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了<code class="docutils literal notranslate"><span class="pre">unlock()</span></code>。与<code class="docutils literal notranslate"><span class="pre">std::lock_guard</span></code>相比，<code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code>更加灵活，<code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code>的对象会以独占所有权（没有其他的<code class="docutils literal notranslate"><span class="pre">unique_lock</span></code>对象同时拥有某个<code class="docutils literal notranslate"><span class="pre">mutex</span></code>对象的所有权）的方式管理<code class="docutils literal notranslate"><span class="pre">mutex</span></code>对象上的上锁和解锁操作。所以在并发编程中推荐使用<code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code>。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code>可以在声明后的任意位置显式调用<code class="docutils literal notranslate"><span class="pre">lock</span></code>和<code class="docutils literal notranslate"><span class="pre">unlock</span></code>，相比于<code class="docutils literal notranslate"><span class="pre">std::lock_guard</span></code>可以缩小锁的作用范围，提供更高的并发度。</p>
</div></blockquote>
<p>如果你用到了条件变量<code class="docutils literal notranslate"><span class="pre">std::condition_variable::wait</span></code>则必须使用<code class="docutils literal notranslate"><span class="pre">std::unique_lock</span></code>作为参数，例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">critical_section</span><span class="p">(</span><span class="kt">int</span> <span class="n">change_v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>

    <span class="c1">// 执行竞争操作</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">change_v</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;v:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 提前释放锁, 提高并发度</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

    <span class="c1">// 在此期间任何人都可以抢夺v的持有权</span>

    <span class="c1">// 开始另一组竞争操作, 再次加锁</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">v</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;v:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">critical_section</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">t2</span><span class="p">(</span><span class="n">critical_section</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">c++11</span></code>提供了如下的4种互斥量，需要包含头文件<code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;mutex&gt;</span></code></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>std::mutex                  // 独占的互斥量，不能递归使用
std::timed_mutex            // 超时的互斥量，不能递归使用
std::recursive_mutex        // 递归互斥量，不带超时功能
std::recursive_timed_mutex  // 带超时的递归互斥量
</pre></div>
</div>
<div class="section" id="std-mutex">
<h3>1. std::mutex<a class="headerlink" href="#std-mutex" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>用<code class="docutils literal notranslate"><span class="pre">lock</span></code>和<code class="docutils literal notranslate"><span class="pre">unlock</span></code>进行独占，此时要保证锁被正确释放，如<code class="docutils literal notranslate"><span class="pre">lock</span></code>和<code class="docutils literal notranslate"><span class="pre">unlock</span></code>之间程序异常而退出，则会导致死锁等问题</p></li>
<li><p>用<code class="docutils literal notranslate"><span class="pre">try_lock</span></code>可以尝试获得锁，返回<code class="docutils literal notranslate"><span class="pre">bool</span></code>值</p></li>
<li><p>可以用<code class="docutils literal notranslate"><span class="pre">lock_guard</span></code>简化<code class="docutils literal notranslate"><span class="pre">lock</span></code>和<code class="docutils literal notranslate"><span class="pre">unlock</span></code>写法，这种写法更加安全，可以保证出了作用域之后锁被释放</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">g_lock</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">g_lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;entered thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;leaving thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="n">g_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> 
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">f2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">locker</span><span class="p">(</span><span class="n">g_lock</span><span class="p">);</span>     
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;entered thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;leaving thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span> 
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">entered</span> <span class="n">thread0x70000c99b000</span>
<span class="n">leaving</span> <span class="n">thread0x70000c99b000</span>
<span class="n">entered</span> <span class="n">thread0x70000ca1e000</span>
<span class="n">leaving</span> <span class="n">thread0x70000ca1e000</span>
<span class="n">entered</span> <span class="n">thread0x70000caa1000</span>
<span class="n">leaving</span> <span class="n">thread0x70000caa1000</span>
<span class="n">entered</span> <span class="n">thread0x70000cb24000</span>
<span class="n">leaving</span> <span class="n">thread0x70000cb24000</span>
<span class="n">entered</span> <span class="n">thread0x70000cba7000</span>
<span class="n">leaving</span> <span class="n">thread0x70000cba7000</span>
<span class="n">entered</span> <span class="n">thread0x70000cc2a000</span>
<span class="n">leaving</span> <span class="n">thread0x70000cc2a000</span>
</pre></div>
</div>
</div>
<div class="section" id="std-recursive-mutex">
<h3>2. std::recursive_mutex<a class="headerlink" href="#std-recursive-mutex" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>当同一个线程多次获取锁时，使用<code class="docutils literal notranslate"><span class="pre">mutex</span></code>会造成死锁，<code class="docutils literal notranslate"><span class="pre">std::recursive_mutex</span></code>允许同一个线程多次获取锁</p></li>
<li><p>不建议使用递归互斥量，因为它的效率比较低，而且应用场景可以通过优化来避免。当获取达到一定的次数后会抛出<code class="docutils literal notranslate"><span class="pre">std::system</span></code>错误</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="c1">//std::mutex mutex; //死锁 </span>
    <span class="n">T</span> <span class="n">mutex</span><span class="p">;</span> 
    
    <span class="kt">void</span> <span class="nf">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
    <span class="p">}</span> 
    <span class="kt">void</span> <span class="nf">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">B</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
    <span class="n">Test</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span>
    <span class="n">Test</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">recursive_mutex</span><span class="o">&gt;</span> <span class="n">test2</span><span class="p">;</span>
    <span class="c1">//test.C(23,32); //这个会发生死锁 </span>
    <span class="n">test2</span><span class="p">.</span><span class="n">C</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
<span class="p">}</span> 
</pre></div>
</div>
<p>输出：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="std-timed-mutexstd-recursive-timed-mutex">
<h3>3. 带超时的互斥量<code class="docutils literal notranslate"><span class="pre">std::timed_mutex</span></code>和<code class="docutils literal notranslate"><span class="pre">std::recursive_timed_mutex</span></code><a class="headerlink" href="#std-timed-mutexstd-recursive-timed-mutex" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::timed_mutex</span></code>是带超时的独占锁</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::recursive_timed_mutex</span></code>是带超时的递归锁</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">timed_mutex</span> <span class="n">mutex</span><span class="p">;</span>


<span class="kt">void</span> <span class="nf">work</span><span class="p">(</span><span class="kt">int</span> <span class="n">_timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_sleepDuration</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">timeout</span><span class="p">(</span><span class="n">_timeout</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">sleepDuration</span><span class="p">(</span><span class="n">_sleepDuration</span><span class="p">);</span>
    
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">mutex</span><span class="p">.</span><span class="n">try_lock_for</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:get lock&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">sleepDuration</span><span class="p">);</span>
            <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:fail to get lock&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">sleepDuration</span><span class="p">);</span>
        
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    
<span class="p">}</span> 
</pre></div>
</div>
</div>
</div>
<div class="section" id="future">
<h2>期物Future<a class="headerlink" href="#future" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">std::future</span></code>提供了一个访问异步操作结果的途径。</p>
<p>举个例子：试想一下我们的主线程A希望开辟一个线程B去异步执行某个任务，并在某个特定的时间点获得B的结果。在C++11的<code class="docutils literal notranslate"><span class="pre">std::future</span></code>被引入之前，通常的做法是：创建一个线程A，在线程A里启动任务B，当准备完毕后发送一个事件并将结果保存在全局变量中。主线程A可以接着处理其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。而C++11提供的<code class="docutils literal notranslate"><span class="pre">std::future</span></code>简化了这个流程，可以用来获取异步任务的结果：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 将一个返回值为7的lambda表达式封装到task中</span>
    <span class="c1">// std::packaged_task的模板参数为要封装函数的类型</span>
    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([](){</span> <span class="k">return</span> <span class="mi">7</span><span class="p">;</span> <span class="p">});</span>

    <span class="c1">// 在一个线程中执行task, 调用wait()阻塞直到期物完成</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">)).</span><span class="n">detach</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;waiting...&quot;</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>

    <span class="c1">// 输出执行结果</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;done!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;future result is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>条件变量<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<div class="section" id="id5">
<h3>1. 简介<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>条件变量是并发编程的一种同步机制，并且几乎总是和互斥量一起使用的，它可以使得线程一直阻塞直到某个条件发生后再继续执行。条件变量是在多线程中实现“等待-&gt;唤醒”逻辑的常用方法，主要包含两个动作：</p>
<ul class="simple">
<li><p>一个线程等待条件变量的条件成立而挂起</p></li>
<li><p>另一个线程负责使条件成立</p></li>
</ul>
<blockquote>
<div><p>Tips：条件变量本身并不包含条件，因为它通常与<code class="docutils literal notranslate"><span class="pre">if</span></code>或者<code class="docutils literal notranslate"><span class="pre">while</span></code>同时使用，所以才被称为条件变量。</p>
</div></blockquote>
</div>
<div class="section" id="id6">
<h3>2. 有互斥锁后还需要条件变量的原因<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>并发编程有两大需求，一是互斥（线程间存在共享数据），一是等待（线程间存在依赖）。互斥可以通过互斥量实现，等待则需要条件变量来实现。考虑一下生产者和消费者模型，其中生产者和消费者各是一个队列，消费者线程依赖生产者线程<code class="docutils literal notranslate"><span class="pre">push</span></code>元素进入任务队列。假设没有条件变量，那么消费者需要一直加锁轮询队列，在队列已经为空时是相当耗费性能的。有了条件变量后我们就可以用事件模式了：消费者线程发现队列为空后就告诉操作系统自己需要<code class="docutils literal notranslate"><span class="pre">wait</span></code>直到生产者线程发信号来唤醒自己。</p>
<p>对比一下两种方式：</p>
<ul class="simple">
<li><p>加锁轮询队列：性能较差（消耗cpu）</p></li>
<li><p>事件模式：性能不会太差（存在切换上下文的开销）</p></li>
</ul>
</div>
<div class="section" id="id7">
<h3>3. 实例<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>下面是一个生产者和消费者的例子：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">produced_nums</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">notified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 通知信号</span>

    <span class="c1">// 生产者</span>
    <span class="k">auto</span> <span class="n">producer</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">900</span><span class="p">));</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="s">&quot;producing &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">produced_nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">notified</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">cv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>  <span class="c1">// 生产者线程每次push元素都通知消费者线程(此处也可以用notify_one)</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// 消费者</span>
    <span class="k">auto</span> <span class="n">consumer</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">notified</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 避免虚假唤醒</span>
                <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// 短暂取消锁, 使得生产者有机会在消费者消费空前继续生产</span>
            <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
            <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>  <span class="c1">// 消费者慢于生产者</span>
            <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">produced_nums</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;consuming &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">produced_nums</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">produced_nums</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">notified</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// 分别在不同的线程中运行</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">p</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">cs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">p</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h2>原子操作<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>现在CPU体系结构提供了CPU指令级的原子操作，因此提供了C++11中多线程并发读写共享变量另一个思路。<code class="docutils literal notranslate"><span class="pre">std::atomic</span></code>模板可以实例化一个原子类型，将一个原子类型读写操作从一组指令最小化到单个CPU指令，例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([](){</span>
        <span class="n">count</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">([](){</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// 等价于fetch_add</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 等价于fetch_add</span>
    <span class="p">});</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于CPU的架构以及实例化的类型结构是否满足该架构对内存对齐条件的要求。我们可以通过<code class="docutils literal notranslate"><span class="pre">std::atomic&lt;T&gt;::is_lock_free</span></code>来检查该原子类型是否支持原子操作：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">// 需要链接-latomic</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">is_lock_free</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 输出:</span>
<span class="nb">true</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>一致性模型<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>如果我们强行将一个变量<code class="docutils literal notranslate"><span class="pre">v</span></code>在多个线程之间的操作设为原子操作（比如加锁），即任何一个线程在操作完<code class="docutils literal notranslate"><span class="pre">v</span></code>后其他线程均能同步感知到<code class="docutils literal notranslate"><span class="pre">v</span></code>的变化。则对于<code class="docutils literal notranslate"><span class="pre">v</span></code>而言表现为顺序执行的程序，它并没有由于引入多线程而得到任何效率上的收益。对此有什么办法可以适当地加速呢？答案便是削弱原子操作在进程间的同步条件。</p>
<p>从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。削弱进程间的同步条件，通常会考虑四种不同的一致性模型：</p>
<div class="section" id="id10">
<h3>1. 线性一致性<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>线性一致性又称强一致性或原子一致性，它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。</p>
<img src="image/1-1967422.png" alt="线性一致性" style="zoom: 67%;" /><p>在这种情况下<code class="docutils literal notranslate"><span class="pre">T1</span></code>和<code class="docutils literal notranslate"><span class="pre">T2</span></code>对<code class="docutils literal notranslate"><span class="pre">x</span></code>的两次写操作时原子的，且<code class="docutils literal notranslate"><span class="pre">x.store(1)</span></code>是严格发生在<code class="docutils literal notranslate"><span class="pre">x.store(2)</span></code>之前，<code class="docutils literal notranslate"><span class="pre">x.store(2)</span></code>是严格发生在<code class="docutils literal notranslate"><span class="pre">x.load()</span></code>之前。值得一提的是，线性一致性对全局时钟的要求是难以实现的，这也是人们不断研究比这个一致性更弱条件下其他一致性算法的原因。</p>
</div>
<div class="section" id="id11">
<h3>2. 顺序一致性<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>顺序一致性同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。</p>
<p><img alt="顺序一致性" src="../../_images/2-1967422.png" /></p>
<p>在顺序一致性的要求下，<code class="docutils literal notranslate"><span class="pre">x.load()</span></code>必须读到最近一次写入的数据，因此<code class="docutils literal notranslate"><span class="pre">x.store(2)</span></code>与<code class="docutils literal notranslate"><span class="pre">x.store(1)</span></code>并无任何先后保障，即只要<code class="docutils literal notranslate"><span class="pre">T2</span></code>的<code class="docutils literal notranslate"><span class="pre">x.store(2)</span></code>发生在<code class="docutils literal notranslate"><span class="pre">x.store(3)</span></code>之前即可。</p>
</div>
<div class="section" id="id12">
<h3>3. 因果一致性<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>因果一致性的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不作要求。</p>
<p><img alt="因果一致性" src="../../_images/3-1967422.png" />上面给出的三个例子都是属于因果一致性的，因为整个过程只有对和产生依赖，而和在此例子中表现为没有关系（虽然实际情况中我们需要更详细的信息才能确定和确实无关）。</p>
</div>
<div class="section" id="id13">
<h3>4. 最终一致性<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>最终一致性是最弱的一致性要求，它只保障某个操作在未来的某个时间点上会被观察到，但并非要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间总是有界的。</p>
<p><img alt="最终一致性" src="../../_images/4-1967422.png" />在上面的情况中，如果我们假设<code class="docutils literal notranslate"><span class="pre">x</span></code>的初始值为<code class="docutils literal notranslate"><span class="pre">0</span></code>，则<code class="docutils literal notranslate"><span class="pre">T2</span></code>中四次<code class="docutils literal notranslate"><span class="pre">x.read()</span></code>结果可能但不限于以下情况：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="m">3</span> <span class="m">4</span> <span class="m">4</span> <span class="m">4</span>  // x的写操作被很快观察到
<span class="m">0</span> <span class="m">3</span> <span class="m">3</span> <span class="m">4</span>  // x的写操作被观察到的时间存在一定延迟
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">4</span>  // 最后一次读操作读到了x的最终值, 但此前的变化未被观察到
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>  // 在当前时间段内x的写操作均未被观察到，但未来某个时间点上一定能观察到x为4的情况
</pre></div>
</div>
</div>
</div>
<div class="section" id="id14">
<h2>内存顺序<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<div class="section" id="id15">
<h3>1. 简介<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>内存顺序描述了计算机CPU获取内存的顺序，内存排序极可能发生在编译器编译期间，也可能发生在CPU指令执行期间。为了尽可能提高程序性能，编译器和CPU会对指令重新排序，并且现代CPU拥有多级cache，这些都可能导致多个线程观察到的变量修改顺序不一致。比如下面这个例子：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// a和b均初始化为0</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 可能输出0或者42, 取决于内存顺序</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在上面的例子中，线程<code class="docutils literal notranslate"><span class="pre">t2</span></code>输出<code class="docutils literal notranslate"><span class="pre">a</span></code>的值既有可能是0也有可能是42，这取决于内存顺序。原子操作涉及两个含义：</p>
<ul class="simple">
<li><p>原子操作不可分</p></li>
<li><p>原子操作是多个线程之间的一个同步点（执行原子操作时会对原子操作前后的内存进行一些必要的同步，从而影响这些操作在不同线程之间的可见情况）</p></li>
</ul>
<p>至于哪些操作会在多线程间同步，取决于我们指定的内存顺序。</p>
</div>
<div class="section" id="id16">
<h3>2. 内存顺序<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>C++的内存模型规定了6种内存顺序，每种内存顺序要求同步的操作都不一样（当然对性能的影响也不一样），并且有些内存顺序是可以/需要配合使用的。</p>
<div class="section" id="memory-order-relaxed">
<h4>2.1 memory_order_relaxed<a class="headerlink" href="#memory-order-relaxed" title="永久链接至标题">¶</a></h4>
<p>只保证原子操作的原子性，不影响这个同步点前后的内存操作。这是原子操作中最宽松的内存顺序，无法解决上述例子的同步问题。</p>
</div>
<div class="section" id="memory-order-acquire">
<h4>2.2 memory_order_acquire<a class="headerlink" href="#memory-order-acquire" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><p>Tips：<code class="docutils literal notranslate"><span class="pre">memory_order_acquire</span></code>和<code class="docutils literal notranslate"><span class="pre">memory_order_release</span></code>往往配合使用。</p>
</div></blockquote>
<p>提供<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">acquire</span></code>语义，适用于<code class="docutils literal notranslate"> <span class="pre">atomic</span> <span class="pre">load</span></code>操作。从执行<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">acquire</span></code>的线程来看，<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">acquire</span> </code>语意会阻止原子操作之后的所有读和写被重排到原子操作之前。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">// 不可能被重排到A.load(std::memory_order_acquire)之前</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-order-release">
<h4>2.3 memory_order_release<a class="headerlink" href="#memory-order-release" title="永久链接至标题">¶</a></h4>
<p>提供<code class="docutils literal notranslate"><span class="pre">write</span> <span class="pre">release</span> </code>语义，适用于<code class="docutils literal notranslate"><span class="pre">atomic</span> <span class="pre">store</span></code>操作。从执行<code class="docutils literal notranslate"><span class="pre">write</span> <span class="pre">release</span></code>的线程来看，<code class="docutils literal notranslate"><span class="pre">write</span> <span class="pre">release</span></code>语意会阻止原子操作之前的所有读和写被重排到原子操作之后。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">// 不可能被乱序到A.store(1, std::memory_order_release)之后</span>
<span class="n">A</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</pre></div>
</div>
<p>回到一开始的例子，使用<code class="docutils literal notranslate"><span class="pre">release-acquire</span></code>语义可以保证线程<code class="docutils literal notranslate"><span class="pre">t2</span></code>观察到<code class="docutils literal notranslate"><span class="pre">b</span></code>变成1时，能观察到<code class="docutils literal notranslate"><span class="pre">a</span></code>变成42。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// a和b均初始化为0</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
        <span class="n">b</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>  <span class="c1">// 对a赋值42不可能被重排到b.store()之后</span>
    <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>   <span class="c1">// 必定输出42</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-order-consume">
<h4>2.4 memory_order_consume<a class="headerlink" href="#memory-order-consume" title="永久链接至标题">¶</a></h4>
<p>同样作用于<code class="docutils literal notranslate"><span class="pre">atomic</span> <span class="pre">load</span></code>操作，但是<code class="docutils literal notranslate"><span class="pre">memory_order_consume</span></code>语义弱于<code class="docutils literal notranslate"><span class="pre">memory_order_acquire</span></code>。从执行<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">consume</span></code>的线程来看，<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">consume</span></code>语义会阻止原子操作之后有依赖关系的读写操作被重排到原子操作之前。（对比一下，<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">acquire</span></code>是阻止原子操作之后所有的读写操作被重排到原子操作之前）</p>
<blockquote>
<div><p>Tips：根据<code class="docutils literal notranslate"><span class="pre">cppreference</span></code>的文档说明，不鼓励使用<code class="docutils literal notranslate"><span class="pre">memory_order_consume</span></code>这个内存顺序：</p>
<p>The specification of release-consume ordering is being revised, and the use of memory_order_consume is temporarily discouraged.(since C++17)</p>
</div></blockquote>
</div>
<div class="section" id="memory-order-acq-rel">
<h4>2.5 memory_order_acq_rel<a class="headerlink" href="#memory-order-acq-rel" title="永久链接至标题">¶</a></h4>
<p>对一个<code class="docutils literal notranslate"><span class="pre">load-modify-store</span></code>的原子操作施加<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">acquire</span></code>和<code class="docutils literal notranslate"><span class="pre">write</span> <span class="pre">release</span></code>的内存顺序限制，比如<code class="docutils literal notranslate"><span class="pre">fetch_add</span></code>。</p>
</div>
<div class="section" id="memory-order-seq-cst">
<h4>2.6 memory_order_seq_cst<a class="headerlink" href="#memory-order-seq-cst" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">memory_order_seq_cst</span></code>是最严格的内存顺序：</p>
<ul class="simple">
<li><p>对于<code class="docutils literal notranslate"><span class="pre">atomic_load</span></code>会执行<code class="docutils literal notranslate"><span class="pre">acquire</span></code>语义</p></li>
<li><p>对于<code class="docutils literal notranslate"><span class="pre">atomic</span> <span class="pre">store</span></code>会执行<code class="docutils literal notranslate"><span class="pre">release</span></code>语义</p></li>
<li><p>对于<code class="docutils literal notranslate"><span class="pre">load-modify-store</span></code>会执行<code class="docutils literal notranslate"><span class="pre">acquire-release</span></code>语义</p></li>
</ul>
<p>除此之外，它还保证所有线程观察到的所有原子变量的修改顺序是一致的。</p>
</div>
</div>
</div>
<div class="section" id="id17">
<h2>内存模型<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<p>为了追求极致的性能，实现各种强度要求的一致性，C++11为原子操作定义了六种不同的内存顺序<code class="docutils literal notranslate"><span class="pre">std::memory_order</span></code>选项，表达了四种多线程间的同步模型。</p>
<div class="section" id="id18">
<h3>1. 宽松模型<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>宽松模型通过<code class="docutils literal notranslate"><span class="pre">std::memory_order_relaxed</span></code>指定，在此模型下单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。</p>
</div>
<div class="section" id="id19">
<h3>2. 释放/消费模型<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程A完成了三次对<code class="docutils literal notranslate"><span class="pre">x</span></code>的写操作，线程B仅依赖其中第三次<code class="docutils literal notranslate"><span class="pre">x</span></code>的写操作，与<code class="docutils literal notranslate"><span class="pre">x</span></code>的前两次写行为无关，则当A主动执行释放<code class="docutils literal notranslate"><span class="pre">x</span></code>的时候（使用<code class="docutils literal notranslate"><span class="pre">std::memory_order_release</span></code>），选项<code class="docutils literal notranslate"><span class="pre">std::memory_order_consume</span></code>能够确保B在调用<code class="docutils literal notranslate"><span class="pre">x.load()</span></code>时候观察到A中第三次对<code class="docutils literal notranslate"><span class="pre">x</span></code>的写操作。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 初始化为nullptr防止consumer线程读取野指针</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">producer</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
        <span class="n">ptr</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">consumer</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">)))</span> <span class="p">{}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;p: &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;v: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">producer</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">consumer</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h3>3. 释放/获取模型<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放<code class="docutils literal notranslate"><span class="pre">std::memory_order_release</span></code>和获取<code class="docutils literal notranslate"><span class="pre">std::memory_order_require</span></code>之间规定时序，即发生在释放操作之前的所有写操作，对其他线程的任何获取操作都是可见的。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">release</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="n">flag</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>  <span class="c1">// write release保证v.push_back(42)肯定执行成功</span>
    <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">acqrel</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="c1">// compare_exchange_strong: 将this值与expect比较, 相等则改成desire值并返回true, 否则返回false</span>
        <span class="kt">int</span> <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// must before compare_exchange_strong</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// must after compare_exchange_strong</span>
        <span class="p">}</span>
        <span class="c1">// flag has changed to 2</span>
    <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">acquire</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// must be 42</span>
    <span class="p">});</span>

    <span class="n">release</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">acqrel</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">acquire</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>4. 顺序一致模型<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>顺序一致模型下原子操作满足顺序一致性，进而可能对性能产生损耗。可以显式通过<code class="docutils literal notranslate"><span class="pre">std::memory_order_seq_cst</span></code>进行指定：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">vt</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
            <span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">t</span> <span class="p">:</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;current counter:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="永久链接至标题">¶</a></h2>
<p>[1] https://www.jianshu.com/p/01ad36b91d39</p>
<p>[2] https://punmy.cn/categories/Code/</p>
<p>[3] https://www.zhihu.com/question/68017337/answer/796332672</p>
<p>[4] https://zhuanlan.zhihu.com/p/45566448</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="10.10%20%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7.html" class="btn btn-neutral float-right" title="10.10 固有的不可移植的特性" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="10.8%20%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98.html" class="btn btn-neutral float-left" title="10.8 手动管理内存" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, TOMOCAT.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>