

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>4.1 常用运算符 &mdash; C++ Note v1.0 文档</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="4.2 运算符优先级" href="4.2%20%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html" />
    <link rel="prev" title="第4章 运算符" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> C++ Note
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC1%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/index.html">第1章 变量与基本类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC2%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/index.html">第2章 语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC3%E7%AB%A0%20%E5%87%BD%E6%95%B0/index.html">第3章 函数</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第4章 运算符</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.1 常用运算符</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">算术运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">1. 优先级和结合律</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">2. 溢出</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">3. 除法与负号</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">4. 取余与负号</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">逻辑运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">1. 逻辑与和逻辑或的短路求值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">2. 不要连写关系运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">赋值运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">1. 运算对象与返回结果</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">2. 初始化列表赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">3. 赋值运算符满足右结合律</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">4. 赋值运算符优先级较低</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id15">递增和递减运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">1. 前置版本和后置版本</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">2. 后置版本的可能使用场景</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id18">成员访问运算符</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">条件运算符</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">位运算符（左结合律）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id21">1. 移位运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">2. 位求反运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">3. 位与、位或和位异或</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sizeof">sizeof运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id24">1. 不同类型的sizeof运算结果</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">2. sizeof返回常量表达式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">3. sizeof中解引用指针</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id27">逗号运算符</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="4.2%20%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html">4.2 运算符优先级</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.3%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6.html">4.3 重载运算符</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC5%E7%AB%A0%20%E7%B1%BB/index.html">第5章 类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC6%E7%AB%A0%20%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B/index.html">第6章 标准库类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC7%E7%AB%A0%20%E6%A8%A1%E6%9D%BF/index.html">第7章 模板</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC8%E7%AB%A0%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%A6%82%E5%BF%B5/index.html">第8章 关键字概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC9%E7%AB%A0%20%E7%AE%97%E6%B3%95/index.html">第9章 算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC10%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/index.html">第10章 语法特性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC11%E7%AB%A0%20C%2B%2B11%E6%96%B0%E6%A0%87%E5%87%86/index.html">第11章 C++11新标准</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">README</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">C++ Note</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第4章 运算符</a> &raquo;</li>
        
      <li>4.1 常用运算符</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/docs/第4章 运算符/4.1 常用运算符.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>4.1 常用运算符<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>算术运算符<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<table border="1" class="docutils">
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一元正号</td>
<td>+ expr</td>
</tr>
<tr>
<td>-</td>
<td>一元负号</td>
<td>- expr</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>expr * expr</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>expr / expr</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
<td>expr % expr</td>
</tr>
<tr>
<td>+</td>
<td>加法</td>
<td>expr + expr</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>expr - expr</td>
</tr>
</tbody>
</table><div class="section" id="id3">
<h3>1. 优先级和结合律<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>一元运算符的优先级最高，然后是乘法和除法，优先级最低的是加法和减法。上面所有的运算符都满足左结合律，意味着优先级相同时满足从左到右的顺序进行组合。</p>
</div>
<div class="section" id="id4">
<h3>2. 溢出<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>当计算结果超出该类型所能表示的范围时可能产生溢出，比如最大的<code class="docutils literal notranslate"><span class="pre">short</span></code>型数值为<code class="docutils literal notranslate"><span class="pre">32767</span></code>，这时候<code class="docutils literal notranslate"><span class="pre">+1</span></code>可能输出<code class="docutils literal notranslate"><span class="pre">-32768</span></code>（这是因为符号位从<code class="docutils literal notranslate"><span class="pre">0</span></code>变为<code class="docutils literal notranslate"><span class="pre">1</span></code>，从而变成负值）。当然在别的系统程序的行为可能不同甚至崩溃。</p>
</div>
<div class="section" id="id5">
<h3>3. 除法与负号<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：C++语言的早期版本允许结果为负值的商向上或向下取整，C++11新标准规定商一律向0取整（即直接切除小数部分）。如果两个运算对象的符号相同则商为正，否则商为负。</p>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mi">21</span> <span class="o">/</span> <span class="mi">6</span><span class="p">;</span>    <span class="c1">// 3</span>
<span class="mi">-21</span> <span class="o">/</span> <span class="mi">-6</span><span class="p">;</span>  <span class="c1">// 3</span>
<span class="mi">21</span> <span class="o">/</span> <span class="mi">-6</span><span class="p">;</span>   <span class="c1">// -3</span>
<span class="mi">-21</span> <span class="o">/</span> <span class="mi">6</span><span class="p">;</span>   <span class="c1">// -3</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>4. 取余与负号<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：如果<code class="docutils literal notranslate"><span class="pre">m%n</span></code>不等于0，那么运算结果的符号和m相同。</p>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mi">21</span> <span class="o">%</span> <span class="mi">6</span><span class="p">;</span>    <span class="c1">// 3</span>
<span class="mi">21</span> <span class="o">%</span> <span class="mi">7</span><span class="p">;</span>    <span class="c1">// 0</span>
<span class="mi">-21</span> <span class="o">%</span> <span class="mi">-8</span><span class="p">;</span>  <span class="c1">// -5</span>
<span class="mi">21</span> <span class="o">%</span> <span class="mi">-5</span><span class="p">;</span>   <span class="c1">// 1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h2>逻辑运算符<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<table border="1" class="docutils">
<thead>
<tr>
<th>结合律</th>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>右</td>
<td>!</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;</td>
<td>小于</td>
<td>expr &lt; expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;=</td>
<td>小于等于</td>
<td>expr &lt;= expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;</td>
<td>大于</td>
<td>expr &gt; expr</td>
</tr>
<tr>
<td>左</td>
<td>>=</td>
<td>大于等于</td>
<td>expr &gt;= expr</td>
</tr>
<tr>
<td>左</td>
<td>==</td>
<td>相等</td>
<td>expr == expr</td>
</tr>
<tr>
<td>左</td>
<td>!=</td>
<td>不等</td>
<td>expr != expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr &amp;&amp; expr</td>
</tr>
<tr>
<td>左</td>
<td>||</td>
<td>逻辑或</td>
<td>expr || expr</td>
</tr>
</tbody>
</table><div class="section" id="id8">
<h3>1. 逻辑与和逻辑或的短路求值<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>逻辑与<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>和逻辑或<code class="docutils literal notranslate"><span class="pre">||</span></code>都是先求左侧对象的值再求右侧运算对象的值，<strong>当且仅当左侧运算对象无法确定表达式的结果才会计算右侧运算对象的值</strong>，这种策略被称为短路求值。基于短路求值的特点，我们可以通过左侧运算对象来确保右侧运算对象求值的正确性和安全性：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 只能左侧运算对象为真则右侧运算对象才安全</span>
<span class="n">index</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>2. 不要连写关系运算符<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>因为关系运算符的求值结果是布尔值，所以将几个关系运算符连写在一起会产生意想不到的结果：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 错误写法: 用i &lt; j的布尔值结果与k比较</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
    
<span class="c1">// 正确写法: 使用&amp;&amp;或者||连接</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id10">
<h2>赋值运算符<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<div class="section" id="id11">
<h3>1. 运算对象与返回结果<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>赋值运算符的左侧运算对象必须是一个可修改的左值，返回的结果是它的左侧运算对象（仍然是左值）。</p>
<blockquote>
<div><p>Tips：注意赋值不等于初始化，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦去，并用一个新值替代它。</p>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 初始化而非赋值</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>         <span class="c1">// 初始化而非赋值, 因此左侧运算对象可以是常量</span>

<span class="mi">1024</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>   <span class="c1">// 错误: 字面值是右值</span>
<span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>  <span class="c1">// 错误: 算数表达式是右值</span>
<span class="n">ci</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>     <span class="c1">// 错误: ci是常量, 是不可修改的左值</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>2. 初始化列表赋值<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>C++11新标准允许使用初始化列表赋值：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1) 编译器warning提示窄化转换: narrowing conversion of ‘3.1499999999999999e+0’ from ‘double’ to ‘int’ inside { }</span>
<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
<span class="n">k</span> <span class="o">=</span> <span class="p">{</span><span class="mf">3.14</span><span class="p">};</span>

<span class="c1">// 2) 无论左侧运算对象类型是什么, 初始值列表都可以为空, 此时编译器创造一个值初始化的临时量并将其赋给左侧运算对象</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">{};</span>  <span class="c1">// i值为0</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>3. 赋值运算符满足右结合律<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>在下面的例子中，先执行<code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">=</span> <span class="pre">0</span></code>，返回左侧运算对象，再执行<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">j</span></code>，因此执行结束后两个变量都被赋值为0。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>4. 赋值运算符优先级较低<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>由于赋值运算符的优先级低于关系运算符的优先级，因此在条件语句中，赋值部分通常应该加上括号：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="c1">// 如果i = get_value()左右两侧不加括号的话, 含义就截然不同</span>
<span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id15">
<h2>递增和递减运算符<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><p>编码规范：对于迭代器和其他模板对象使用前缀形式的自增（自减）运算符。不考虑返回值的情况下，前置自增<code class="docutils literal notranslate"><span class="pre">++i</span></code>通常比后置自增<code class="docutils literal notranslate"><span class="pre">i++</span></code>效率高，因为后置自增需要对表达式的值<code class="docutils literal notranslate"><span class="pre">i</span></code>进行一次拷贝，如果<code class="docutils literal notranslate"><span class="pre">i</span></code>是迭代器或其他非数值类型，拷贝的代价是比较大的。</p>
</div></blockquote>
<div class="section" id="id16">
<h3>1. 前置版本和后置版本<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>前置版本会将运算对象加1（或减1），然后将改变后的对象作为求值结果。后置版本也会将运算对象加1（或减1），但是求值结果是运算对象改变之前值的副本。这两种运算符必须作用于左侧运算对象，其中前置版本将对象本身作为左值返回，后置版本将对象原始值的副本的作为右值返回。</p>
<blockquote>
<div><p>Tips：除非必须，否则不用递增递减运算符的后置版本。前置版本的递增运算将值加1之后直接返回该运算对象，但是后置版本需要将原始值存储下来以便于返回这个未修改的内容，如果我们不需要修改前的值的话就是一种性能上的浪费。对于整数和指针类型而言，编译器可能对这种额外的工作进行优化，但是如果是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本习惯，这样不仅不需要担心性能问题，而且不会引入非预期的错误。</p>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<span class="n">j</span> <span class="o">=</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span>    <span class="c1">// j = 1, i = 1: 前置版本得到递增之后的值</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>    <span class="c1">// j = 1, i = 2：后置版本得到递增之前的值</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h3>2. 后置版本的可能使用场景<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>后置版本最常用的场景就是在一条语句中混用解引用和递增运算符的后置版本：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">pbeg</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="c1">// 输出元素直到遇到第一个负值</span>
<span class="k">while</span> <span class="p">(</span><span class="n">pbeg</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pbeg</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pebg</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出当前值并将pbeg向前移动一个元素</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*pbeg++</span></code>这种写法非常普遍，会先把<code class="docutils literal notranslate"><span class="pre">pbeg</span></code>的值加1，然后返回<code class="docutils literal notranslate"><span class="pre">pbeg</span></code>的初始值的副本作为其求解结果，此时解引用的运算对象是<code class="docutils literal notranslate"><span class="pre">pbeg</span></code>未增加之前的值。</p>
</div>
</div>
<div class="section" id="id18">
<h2>成员访问运算符<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<p>点运算符和箭头运算符都可用于访问成员，<code class="docutils literal notranslate"><span class="pre">ptr-&gt;mem</span></code>等价于<code class="docutils literal notranslate"><span class="pre">(*ptr).mem</span></code>。需要注意的是解引用运算符优先级低于点运算符，所以必须加上括号。</p>
</div>
<div class="section" id="id19">
<h2>条件运算符<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<p>条件运算符满足右结合律，意味着运算对象一般按照从右往左的顺序组合，因此我们使用嵌套条件运算符：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">finalgrade</span> <span class="o">=</span> <span class="p">(</span><span class="n">grade</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;high pass&quot;</span>
                            <span class="o">:</span> <span class="p">(</span><span class="n">grade</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;fail&quot;</span> <span class="o">:</span> <span class="s">&quot;pass&quot;</span>
</pre></div>
</div>
<p>注意条件运算符的优先级非常低，所以一条长表达式中嵌套了条件运算子表达式时，通常需要在两端加上括号：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">grade</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;fail&quot;</span> <span class="o">:</span> <span class="s">&quot;pass&quot;</span><span class="p">);</span> <span class="c1">// 输出pass或者fail</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>位运算符（左结合律）<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><p>Tips：如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器，而且此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。</p>
</div></blockquote>
<table border="1" class="docutils">
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>位求反</td>
<td>~ expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>>></td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr &amp; expr</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr ^ expr</td>
</tr>
<tr>
<td>|</td>
<td>位或</td>
<td>expr | expr</td>
</tr>
</tbody>
</table><div class="section" id="id21">
<h3>1. 移位运算符<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>左移运算符<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>在右侧插入值为<code class="docutils literal notranslate"><span class="pre">0</span></code>的二进制位，右移运算符<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>的行为则依赖其左侧运算对象的类型，如果该运算对象是无符号类型，在左侧插入值为<code class="docutils literal notranslate"><span class="pre">0</span></code>的二进制位。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 假定char占8位, int占32位</span>
<span class="c1">// 0233是八进制的字面值</span>
<span class="c1">// 二进制: 100111011</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bits</span> <span class="o">=</span> <span class="mo">0233</span><span class="p">;</span>

<span class="c1">// bits被提升为int类型, 然后向左移动8位</span>
<span class="c1">// 二进制: 00000000 00000000 10011011 00000000</span>
<span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
    
<span class="c1">// 向左移动31位, 左边超出边界的位丢弃掉了</span>
<span class="c1">// 二进制: 10000000 00000000 00000000 00000000</span>
<span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span>
    
<span class="c1">// 向右移动3位, 右边超出边界的位丢弃掉了</span>
<span class="c1">// 二进制: 00000000 00000000 00000000 00010011</span>
<span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h3>2. 位求反运算符<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<p>对于<code class="docutils literal notranslate"><span class="pre">char</span></code>类型的运算对象首先提升为<code class="docutils literal notranslate"><span class="pre">int</span></code>类型，提升时运算对象原来的位保持不变，往高位添加<code class="docutils literal notranslate"><span class="pre">0</span></code>即可。接下来将提升后的值逐位求反。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 假定char占8位, int占32位</span>
<span class="c1">// 0227是八进制的字面值</span>
<span class="c1">// 二进制: 10010111</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bits</span> <span class="o">=</span> <span class="mo">0227</span><span class="p">;</span>

<span class="c1">// char被提升为int型, 往高位添加0</span>
<span class="c1">// 二进制: 00000000 00000000 00000000 10010111</span>

<span class="c1">// 逐位求反</span>
<span class="c1">// 二进制: 11111111 11111111 11111111 01101000</span>
<span class="o">~</span><span class="n">bits</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h3>3. 位与、位或和位异或<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>位与：两个都是<code class="docutils literal notranslate"><span class="pre">1</span></code>则返回<code class="docutils literal notranslate"><span class="pre">1</span></code>，否则为<code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>位或：两个至少有一个为<code class="docutils literal notranslate"><span class="pre">1</span></code>则返回<code class="docutils literal notranslate"><span class="pre">1</span></code>，否则为<code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>位异或：两个有且只有一个为<code class="docutils literal notranslate"><span class="pre">1</span></code>则返回<code class="docutils literal notranslate"><span class="pre">1</span></code></p></li>
</ul>
</div>
</div>
<div class="section" id="sizeof">
<h2>sizeof运算符<a class="headerlink" href="#sizeof" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">sizeof</span></code>运算符返回一条表达式或者一个类型名字所占的字节数，所得的值是一个<code class="docutils literal notranslate"><span class="pre">size_t</span></code>类型（一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小）。当传入一条表达式时，<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>运算符并不实际计算其运算对象的值。</p>
<div class="section" id="id24">
<h3>1. 不同类型的sizeof运算结果<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>对<code class="docutils literal notranslate"><span class="pre">char</span></code>或者类型为<code class="docutils literal notranslate"><span class="pre">char</span></code>的表达式执行<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>，返回<code class="docutils literal notranslate"><span class="pre">1</span></code></p></li>
<li><p>对引用类型执行<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>运算得到被引用对象所占空间的大小</p></li>
<li><p>对指针执行<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>得到指针本身所占空间的大小</p></li>
<li><p>对解引用指针执行<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>运算得到指针你指向的对象所占空间的大小，指针本身不需要有效</p></li>
<li><p>对数组执行<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>运算并将所得结果求和</p></li>
<li><p>对<code class="docutils literal notranslate"><span class="pre">string</span></code>对象或<code class="docutils literal notranslate"><span class="pre">vector</span></code>对象执行<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</p></li>
</ul>
</div>
<div class="section" id="id25">
<h3>2. sizeof返回常量表达式<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<p>因为<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>的返回值是一个常量表达式，因此我们可以用<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>的结果声明数组的维度。</p>
</div>
<div class="section" id="id26">
<h3>3. sizeof中解引用指针<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p>由于<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>满足右结合律并且与<code class="docutils literal notranslate"><span class="pre">*</span></code>运算符的优先级一样，因此<code class="docutils literal notranslate"><span class="pre">sizeof</span> <span class="pre">*p</span></code>等价于<code class="docutils literal notranslate"><span class="pre">sizeof</span> <span class="pre">(*p)</span></code>。另外由于<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>不会实际求运算对象的值，所以在<code class="docutils literal notranslate"><span class="pre">sizeof</span></code>的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正地使用。</p>
</div>
</div>
<div class="section" id="id27">
<h2>逗号运算符<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<p>逗号运算符含有两个运算对象，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值，如果右侧运算对象是左值，那么最终的求值结果也是左值。</p>
<p>逗号运算符通常被用在for循环中：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">ivec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="c1">// 把从size到1的值依次赋给ivec的元素</span>
<span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">ix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ix</span> <span class="o">!=</span> <span class="n">ivec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">ix</span><span class="p">,</span> <span class="o">--</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ivec</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="4.2%20%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html" class="btn btn-neutral float-right" title="4.2 运算符优先级" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="第4章 运算符" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, TOMOCAT.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>