

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1.7 初始化 &mdash; C++ Note v1.0 文档</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="[选读] POD类型" href="%5B%E9%80%89%E8%AF%BB%5DPOD%E7%B1%BB%E5%9E%8B.html" />
    <link rel="prev" title="1.6 类型转换" href="1.6%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> C++ Note
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第1章 变量与基本类型</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.1%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89.html">1.1 变量声明与定义</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.2%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html">1.2 数据类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.3%20C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">1.3 C风格字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.4%20%E6%95%B0%E7%BB%84.html">1.4 数组</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.5%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B.html">1.5 枚举类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.6%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html">1.6 类型转换</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">1.7 初始化</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">总结</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">1. 初始化方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">2. 初始化习惯</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">3. 确保对象被使用前已被初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">初始化不等于赋值</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">默认初始化与值初始化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">1. 内置类型的默认初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">2. 类类型的默认初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">3. 数组的默认初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">4. 内置类型的值初始化（不推荐）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">隐式初始化与显式初始化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">1. 概念</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit">2. explicit禁用构造函数定义的类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">3. 只允许一步隐式类型转换</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id16">直接初始化与拷贝初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">列表初始化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#c-98-03c-11">1. C++98/03与C++11的列表初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vector">2. vector中圆括号与花括号的初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">3. 初始化习惯</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">4. 列表初始化返回值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializer-list">5. initializer_list形参</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="%5B%E9%80%89%E8%AF%BB%5DPOD%E7%B1%BB%E5%9E%8B.html">[选读] POD类型</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC2%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/index.html">第2章 语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC3%E7%AB%A0%20%E5%87%BD%E6%95%B0/index.html">第3章 函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC4%E7%AB%A0%20%E8%BF%90%E7%AE%97%E7%AC%A6/index.html">第4章 运算符</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC5%E7%AB%A0%20%E7%B1%BB/index.html">第5章 类</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC6%E7%AB%A0%20%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B/index.html">第6章 标准库类型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC7%E7%AB%A0%20%E6%A8%A1%E6%9D%BF/index.html">第7章 模板</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC8%E7%AB%A0%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%A6%82%E5%BF%B5/index.html">第8章 关键字概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC9%E7%AB%A0%20%E7%AE%97%E6%B3%95/index.html">第9章 算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC10%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/index.html">第10章 语法特性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%AC%AC11%E7%AB%A0%20C%2B%2B11%E6%96%B0%E6%A0%87%E5%87%86/index.html">第11章 C++11新标准</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">README</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">C++ Note</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第1章 变量与基本类型</a> &raquo;</li>
        
      <li>1.7 初始化</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/docs/第1章 变量与基本类型/1.7 初始化.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>1.7 初始化<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>总结<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>初始化的概念：创建变量时赋予它一个值（不同于赋值的概念）</p></li>
<li><p>类的构造函数控制其对象的初始化过程，无论何时只要类的对象被创建就会执行构造函数</p></li>
<li><p>如果对象未被用户指定初始值，那么这些变量会被执行默认初始化，默认值取决于变量类型和定义变量的位置</p></li>
<li><p>无论何时只要类的对象被创建就会执行构造函数，通过显式调用构造函数进行初始化被称为显式初始化，否则叫做隐式初始化</p></li>
<li><p>使用等号（=）初始化一个类变量执行的是拷贝初始化，编译器会把等号右侧的初始值拷贝到新创建的对象中去，不使用等号则执行的是直接初始化</p></li>
<li><p>传统C++中列表初始化仅能用于普通数组和POD类型，C++11新标准将列表初始化应用于所有对象的初始化（但是内置类型习惯于用等号初始化，类类型习惯用构造函数圆括号显式初始化，vector、map和set等容器类习惯用列表初始化）</p></li>
</ul>
</div>
<div class="section" id="id3">
<h2>编码规范<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<div class="section" id="id4">
<h3>1. 初始化方式<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>变量和数组初始化时用<code class="docutils literal notranslate"><span class="pre">=</span></code>、<code class="docutils literal notranslate"><span class="pre">{}</span></code>和<code class="docutils literal notranslate"><span class="pre">()</span></code>都是可以的：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">x</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>

<span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;tomocat&quot;</span><span class="p">;</span>
<span class="n">string</span> <span class="nf">name</span><span class="p">(</span><span class="s">&quot;tomocat&quot;</span><span class="p">);</span>
<span class="n">string</span> <span class="n">name</span><span class="p">{</span><span class="s">&quot;tomocat&quot;</span><span class="p">};</span>
</pre></div>
</div>
<p>非空列表初始化会优先调用<code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>，不过空列表初始化除外，后者原则上会调用默认构造函数。为了强制禁用<code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>，请使用括号。</p>
</div>
<div class="section" id="id5">
<h3>2. 初始化习惯<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>尽管C++11将列表初始化应用于所有对象的初始化，但是内置类型习惯于用等号初始化，类类型习惯用构造函数圆括号显式初始化，vector、map和set等容器类习惯用列表初始化。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 内置类型初始化(包括string等标准库简单类类型)</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span> <span class="o">=</span> <span class="mf">3.1415926</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;tomocat&quot;</span><span class="p">;</span>

    <span class="c1">// 类类型初始化</span>
    <span class="n">Cat</span> <span class="n">cat1</span><span class="p">();</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">(</span><span class="s">&quot;tomocat&quot;</span><span class="p">);</span>

    <span class="c1">// 容器类型初始化(当然也可以用圆括号初始化, 列表初始化用于显式指明容器内元素)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;tomocat&quot;</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{{</span><span class="s">&quot;k1&quot;</span><span class="p">,</span> <span class="s">&quot;v1&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;k2&quot;</span><span class="p">,</span> <span class="s">&quot;v2&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;k3&quot;</span><span class="p">,</span> <span class="s">&quot;v3&quot;</span><span class="p">}};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">};</span>

    <span class="c1">// 动态分配对象的列表初始化</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">10</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

    <span class="c1">// 动态分配数组的列表初始化</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">parr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>3. 确保对象被使用前已被初始化<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Effective C++：Make sure that objects are initialized before they’re used.</p>
</div></blockquote>
<ul class="simple">
<li><p>为内置类型进行手动初始化，因为C++不保证初始化它们</p></li>
<li><p>构造函数最好使用成员初始值列表（member initialization list），而不要在构造函数本体内使用赋值操作（assignment），并且初始值列表列出的成员变量其排列次序应该和它们在class中声明次序相同。</p></li>
<li><p>为避免“跨编译单元的初始化次序”问题，请以local static对象替换non-local static对象。</p></li>
</ul>
<blockquote>
<div><p>static对象指的是生命周期从被构造出来直到程序结束为止的对象，因此stack和heap对象被排除。static对象包括：</p>
<ul class="simple">
<li><p>global对象</p></li>
<li><p>定义于namespace作用域的对象</p></li>
<li><p>在class内、在函数内和在file作用域内被声明为static的对象</p></li>
</ul>
<p>函数内的static对象被称为local static对象，其他static对象都被称为non-local static对象。程序结束时static对象会被自动销毁，也就是它们的析构函数会在main函数结束时被自动调用。</p>
</div></blockquote>
</div>
</div>
<div class="section" id="id7">
<h2>初始化不等于赋值<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦去，并用一个新值替代它。</p>
<p>C++定义了初始化的好几种不同形式，例如我们定义一个int变量并初始化为0，有如下4种方式：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>默认初始化与值初始化<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><p>Tips：C不允许用户自定义默认值从而提高性能（增加函数调用的代价），C++默认也不做初始化从而提高性能，但是C++提供了构造函数让用户显式设置默认初始值。有个例外是把全局变量初始化为0仅仅在程序启动时会有成本，因此定义在任何函数之外的变量会被初始化为0。</p>
</div></blockquote>
<p>如果定义变量时没有指定初始值，则变量会被默认初始化或值初始化，此时变量被赋予了默认值，这个默认值取决于变量类型和定义位置。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cat</span> <span class="n">cat1</span><span class="p">;</span>          <span class="c1">// 默认初始化</span>
    <span class="n">Cat</span> <span class="n">cat2</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">();</span>  <span class="c1">// 显式请求值初始化</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id9">
<h3>1. 内置类型的默认初始化<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：建议初始化每一个内置类型的变量，原因在于定义在函数内部的内置类型变量的值是未定义的，如果试图拷贝或者以其他形式访问此类值是一种错误的编程行为且很难调试。</p>
</div></blockquote>
<p>如果内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量会被初始化为0，定义在函数体内部的内置类型变量将不被初始化（uninitialized），一个未被初始化的内置类型变量的值时未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">global_value</span><span class="p">;</span>  <span class="c1">// 默认初始化为0</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">local_value</span><span class="p">;</span>  <span class="c1">// 使用了未初始化的局部变量</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">new_value</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;new_value:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">new_value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>       <span class="c1">// 未定义</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;global_value:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">global_value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;local_value:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">local_value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">// 未定义, 且会报warning</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>2. 类类型的默认初始化<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>定义一个类变量但是没有指定初始值时，会使用默认构造函数来初始化，所以没有默认构造函数的类不能执行默认初始化。定义于任何函数体之外的类变量会先进行零初始化再执行默认初始化，定义在函数体内部的类变量会直接执行默认初始化。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="c1">// Cat类使用合成的默认构造函数</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Dog类使用自定义的默认构造函数</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">Dog</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// 默认构造函数, 但是不会初始化age</span>
<span class="p">};</span>

<span class="c1">// 在函数体外部定义的类会先执行零初始化, 再执行默认初始化, 因此虽然默认构造函数不会初始化age变量, 但age仍然是0</span>
<span class="n">Cat</span> <span class="n">global_cat</span><span class="p">;</span>
<span class="n">Dog</span> <span class="n">global_dog</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cat</span> <span class="n">local_cat</span><span class="p">;</span>
    <span class="n">Dog</span> <span class="n">local_dog</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;global_cat age:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">global_cat</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;global_dog age:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">global_dog</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;local_cat age:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">local_cat</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">// 随机值</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;local_dog age:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">local_dog</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>    <span class="c1">// 随机值</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有默认构造函数的类是不能执行默认初始化的：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="c1">// Cat类禁用默认构造函数, 无法默认初始化</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cat</span> <span class="n">local_cat</span><span class="p">;</span>  <span class="c1">// 编译报错: use of deleted function ‘Cat::Cat()’</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从本质上讲，类的初始化取决于构造函数中对数据成员的初始化，如果没有在构造函数的初始值列表中显式地初始化数据成员，那么成员将在构造函数体之前执行默认初始化，例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 通过构造函数初始值列表初始化数据成员: 数据成员通过提供的初始值进行初始化</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Cat</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 数据成员先进行默认初始化, 再通过构造函数参数进行赋值操作</span>
<span class="c1">// 这种方法虽然合法但是比较草率, 造成的影响依赖于数据成员的类型</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Dog</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">age</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>3. 数组的默认初始化<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<ol class="simple">
<li><p>如果定义数组时提供了初始值列表，那么未定义的元素若是内置类型或者有合成的默认构造则会先进行零初始化，如果元素是类类型，再执行默认构造函数</p></li>
<li><p>如果定义数组时未提供初始化列表，则每个元素执行默认初始化</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* 内置类型在函数内部默认初始化, 随机值 */</span>
    <span class="kt">int</span> <span class="n">int_array</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">int_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 全都是随机值</span>
    <span class="p">}</span>

    <span class="cm">/* 定义数组使用初始值列表, 除了前两个元素外都是0 */</span>
    <span class="kt">int</span> <span class="n">int_array2</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span> <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">int_array2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 22,33,0,0,0</span>
    <span class="p">}</span>

    <span class="cm">/* 定义数组使用初始值列表, 都是0 */</span>
    <span class="kt">int</span> <span class="n">int_array3</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">int_array3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 0,0,0,0,0</span>
    <span class="p">}</span>

    <span class="cm">/* 数组元素为类且使用初始值列表时 */</span>
    <span class="n">Cat</span> <span class="o">*</span><span class="n">my_cat</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="p">;</span>
    <span class="n">Cat</span> <span class="n">cat_array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">*</span><span class="n">my_cat</span> <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cat_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 随机值,0,0,0,0</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>4. 内置类型的值初始化（不推荐）<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>对于类类型而言，不指定初始值下会调用它的默认构造函数，因此不存在默认初始化和值初始化的区别。但是对于内置类型值初始化和默认初始化不同，只不过实际开发中我们建议显式初始化内置类型来避免产生未定义值的代码：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>               <span class="c1">// 默认初始化: *pi1的值未定义</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span>             <span class="c1">// 值初始化: *pi2的值为0</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">pia1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>          <span class="c1">// 10个默认初始化的int: 值未定义</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pia2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span>        <span class="c1">// 10个值初始化的int: 值都为0</span>

<span class="n">string</span> <span class="o">*</span><span class="n">psa1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>    <span class="c1">// 10个默认初始化的string: 都为空</span>
<span class="n">string</span> <span class="o">*</span><span class="n">psa2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span>  <span class="c1">// 10个值初始化的string: 都为空</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>隐式初始化与显式初始化<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="section" id="id14">
<h3>1. 概念<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>无论何时只要类的对象被创建就会执行构造函数，通过显式调用构造函数进行初始化被称为显式初始化，否则叫做隐式初始化。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="c1">// Cat提供两个构造函数</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Cat</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cat</span> <span class="n">cat1</span><span class="p">;</span>           <span class="c1">// 隐式初始化: 调用默认构造函数</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>       <span class="c1">// 隐式初始化: 调用一个形参的构造函数</span>

    <span class="n">Cat</span> <span class="n">cat3</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">();</span>   <span class="c1">// 显式初始化: 调用默认构造函数</span>
    <span class="n">Cat</span> <span class="n">cat4</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// 显式初始化: 调用一个形参的构造函数</span>

    <span class="c1">// 构造函数还可以搭配new一起使用, 用于在堆上分配内存</span>
    <span class="n">Cat</span> <span class="o">*</span><span class="n">cat5</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="p">();</span>
    <span class="n">Cat</span> <span class="o">*</span><span class="n">cat6</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">cat5</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">cat6</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>还有一些操作不会显式调用类的构造函数，比如：</p>
<ul class="simple">
<li><p>通过一个实参调用的构造函数定义了从构造函数参数类型向类类型隐式转换的规则</p></li>
<li><p>拷贝构造函数定义了用一个对象初始化另一个对象的隐式转换</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="c1">// Cat提供两个构造函数</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="c1">// 接收一个参数的构造函数定义了从int型向类类型隐式转换的规则, explicit关键字可以组织这种转换</span>
    <span class="n">Cat</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
    <span class="c1">// 拷贝构造函数定义了从一个对象初始化另一个对象的隐式转换</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">orig</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">age</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cat</span> <span class="n">cat1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>    <span class="c1">// 调用接收int参数的拷贝构造函数</span>
    <span class="n">Cat</span> <span class="n">cat2</span> <span class="o">=</span> <span class="n">cat1</span><span class="p">;</span>  <span class="c1">// 调用拷贝构造函数</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cat1</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cat2</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 输出:</span>
<span class="mi">10</span>
<span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit">
<h3>2. explicit禁用构造函数定义的类型转换<a class="headerlink" href="#explicit" title="永久链接至标题">¶</a></h3>
<p>例如智能指针就把构造函数声明为<code class="docutils literal notranslate"><span class="pre">explict</span></code>，所以智能指针只能直接初始化。我们也可以通过explicit禁用掉上面提到的两种隐式转换规则：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// 必须显式调用拷贝构造函数</span>
    <span class="k">explicit</span> <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">orig</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">age</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cat</span> <span class="n">cat1</span><span class="p">;</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">(</span><span class="n">cat1</span><span class="p">);</span>      <span class="c1">// 正确: 显式调用拷贝构造函数</span>
    <span class="c1">// Cat cat3 = cat1;  // 错误: explicit关键字限制了拷贝构造函数的隐式调用</span>

    <span class="c1">// std::shared_ptr&lt;int&gt; sp = new int(8);    // 错误: 不支持隐式调用构造函数</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>        <span class="c1">// OK</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>3. 只允许一步隐式类型转换<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>编译器只会自动执行一步隐式类型转换，如果隐式地使用两种转换规则，那么编译器便会报错：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 允许string到Cat的隐式类型转换</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 错误: 不存在从const char[8]到Cat的类型转换, 编译器不会自动把const char[8]转成string, 再把string转成Cat</span>
    <span class="c1">// Cat cat1 = &quot;tomocat&quot;;</span>

    <span class="c1">// 正确: 显式转换成string, 再隐式转换成Cat</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;tomocat&quot;</span><span class="p">));</span>

    <span class="c1">// 正确: 隐式转换成string, 再显式转换成Cat</span>
    <span class="n">Cat</span> <span class="n">cat3</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">(</span><span class="s">&quot;tomocat&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h2>直接初始化与拷贝初始化<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<p>如果使用等号（=）初始化一个类变量，实际上执行的是拷贝初始化，编译器把等号右侧的值拷贝到新创建的对象中区；如果不使用等号，那么执行的是直接初始化。</p>
<p>以string为例：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;tomocat&quot;</span><span class="p">;</span>    <span class="c1">// 拷贝初始化</span>
<span class="n">string</span> <span class="nf">s2</span><span class="p">(</span><span class="s">&quot;tomocat&quot;</span><span class="p">);</span>     <span class="c1">// 直接初始化</span>
<span class="n">string</span> <span class="nf">s3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span>       <span class="c1">// 直接初始化, s3内容为cccccccccc</span>

<span class="c1">// s4拷贝初始化</span>
<span class="n">string</span> <span class="n">s4</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span>
<span class="c1">// 等价于</span>
<span class="n">string</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span>
<span class="n">string</span> <span class="n">s4</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h2>列表初始化<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<div class="section" id="c-98-03c-11">
<h3>1. C++98/03与C++11的列表初始化<a class="headerlink" href="#c-98-03c-11" title="永久链接至标题">¶</a></h3>
<p>在C++98/03中，普通数组和POD（Plain Old Data，即没有构造、析构和虚函数的类或结构体）类型可以使用花括号<code class="docutils literal notranslate"><span class="pre">{}</span></code>进行初始化，即列表初始化。但是这种初始化方式仅限于上述提到的两种数据类型：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 普通数组的列表初始化</span>
    <span class="kt">int</span> <span class="n">arr1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">arr2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>  <span class="c1">// arr2被编译器自动推断为int[4]类型</span>
    
    <span class="c1">// POD类型的列表初始化</span>
    <span class="k">struct</span> <span class="nc">data</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">my_data</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++11新标准中列表初始化得到了全面应用，不仅兼容了传统C++中普通数组和POD类型的列表初始化，还可以用于任何其他类型对象的初始化：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="c1">// 默认构造函数</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;default constructor of Cat&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 接受一个参数的构造函数</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;normal constructor of Cat&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 拷贝构造函数</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">orig</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;copy constructor of Cat&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">     * 内置类型的列表初始化</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">{</span> <span class="mi">10</span> <span class="p">};</span>       <span class="c1">// 内置类型通过初始化列表的直接初始化</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span> <span class="p">};</span>    <span class="c1">// 内置类型通过初始化列表的拷贝初始化</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;a:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;b:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * 类类型的列表初始化</span>
<span class="cm">     */</span>
    <span class="n">Cat</span> <span class="n">cat1</span><span class="p">{};</span>                 <span class="c1">// 类类型调用默认构造函数的列表初始化</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cat1.name:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cat1</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">{</span> <span class="s">&quot;tomocat&quot;</span> <span class="p">};</span>        <span class="c1">// 类类型调用普通构造函数的列表初始化</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cat2.name:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cat2</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 注意列表初始化前面的等于号并不会影响初始化行为, 这里并不会调用拷贝构造函数</span>
    <span class="n">Cat</span> <span class="n">cat3</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;tomocat&quot;</span> <span class="p">};</span>     <span class="c1">// 类类型调用普通构造函数的列表初始化</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cat3.name:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cat3</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 先通过列表初始化构造右侧Cat临时对象, 再调用拷贝构造函数(从输出上看好像编译器优化了, 直接调用普通构造函数而不会调用拷贝构造函数)</span>
    <span class="n">Cat</span> <span class="n">cat4</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">{</span> <span class="s">&quot;tomocat&quot;</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cat4.name:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cat4</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * new申请堆内存的列表初始化</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span> <span class="mi">100</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*pi:&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">pi</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;arr[2]:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 输出:</span>
<span class="nl">a</span><span class="p">:</span><span class="mi">10</span>
<span class="nl">b</span><span class="p">:</span><span class="mi">10</span>
<span class="k">default</span> <span class="n">constructor</span> <span class="n">of</span> <span class="n">Cat</span>
<span class="n">cat1</span><span class="p">.</span><span class="nl">name</span><span class="p">:</span>
<span class="n">normal</span> <span class="n">constructor</span> <span class="n">of</span> <span class="n">Cat</span>
<span class="n">cat2</span><span class="p">.</span><span class="nl">name</span><span class="p">:</span><span class="n">tomocat</span>
<span class="n">normal</span> <span class="n">constructor</span> <span class="n">of</span> <span class="n">Cat</span>
<span class="n">cat3</span><span class="p">.</span><span class="nl">name</span><span class="p">:</span><span class="n">tomocat</span>
<span class="n">normal</span> <span class="n">constructor</span> <span class="n">of</span> <span class="n">Cat</span>
<span class="n">cat4</span><span class="p">.</span><span class="nl">name</span><span class="p">:</span><span class="n">tomocat</span>
<span class="o">*</span><span class="nl">pi</span><span class="p">:</span><span class="mi">100</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">:</span><span class="mi">30</span>
</pre></div>
</div>
</div>
<div class="section" id="vector">
<h3>2. vector中圆括号与花括号的初始化<a class="headerlink" href="#vector" title="永久链接至标题">¶</a></h3>
<p>总的来说，圆括号是通过调用vector的构造函数进行初始化的，如果使用了花括号那么初始化过程会尽可能会把花括号内的值当做元素初始值的列表来处理。如果初始化时使用了花括号但是提供的值又无法用来列表初始化，那么就考虑用这些值来调用vector的构造函数了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;tomocat&quot;</span><span class="p">};</span>  <span class="c1">// 列表初始化: 包含3个string元素的vector</span>
    <span class="c1">// std::vector&lt;std::string&gt; v2(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);          // 错误: 找不到合适的构造函数</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;tomocat&quot;</span><span class="p">);</span>             <span class="c1">// 10个string元素的vector, 每个string初始化为&quot;tomocat&quot;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;tomocat&quot;</span><span class="p">};</span>             <span class="c1">// 10个string元素的vector, 每个string初始化为&quot;tomocat&quot;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v5</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">// 10个int元素, 每个都初始化为0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v6</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>     <span class="c1">// 1个int元素, 该元素的值时10</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v7</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 10个int元素, 每个都初始化为1</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v8</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>  <span class="c1">// 2个int元素, 值分别是10和1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h3>3. 初始化习惯<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>尽管C++11将列表初始化应用于所有对象的初始化，但是内置类型习惯于用等号初始化，类类型习惯用构造函数圆括号显式初始化，vector、map和set等容器类习惯用列表初始化。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 内置类型初始化(包括string等标准库简单类类型)</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span> <span class="o">=</span> <span class="mf">3.1415926</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;tomocat&quot;</span><span class="p">;</span>

    <span class="c1">// 类类型初始化</span>
    <span class="n">Cat</span> <span class="n">cat1</span><span class="p">();</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">(</span><span class="s">&quot;tomocat&quot;</span><span class="p">);</span>

    <span class="c1">// 容器类型初始化(当然也可以用圆括号初始化, 列表初始化用于显式指明容器内元素)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;tomocat&quot;</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{{</span><span class="s">&quot;k1&quot;</span><span class="p">,</span> <span class="s">&quot;v1&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;k2&quot;</span><span class="p">,</span> <span class="s">&quot;v2&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;k3&quot;</span><span class="p">,</span> <span class="s">&quot;v3&quot;</span><span class="p">}};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">};</span>

    <span class="c1">// 动态分配对象的列表初始化</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">10</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

    <span class="c1">// 动态分配数组的列表初始化</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">parr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>4. 列表初始化返回值<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>C++11新标准规定，函数可以通过列表初始化来对函数返回的临时量进行初始化：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{};</span>  <span class="c1">// 返回一个空vector对象</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;tomocat&quot;</span><span class="p">};</span>  <span class="c1">// 返回列表初始化的vector对象</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="initializer-list">
<h3>5. initializer_list形参<a class="headerlink" href="#initializer-list" title="永久链接至标题">¶</a></h3>
<p>前面提到C++11支持所有类型的列表初始化，对于类类型而言，虽然我们使用列表初始化它会自动调用匹配的构造函数，但是我们也能显式指定接受初始化列表的构造函数。C++11引入了<code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>，允许构造函数或其他函数像参数一样使用初始化列表，这才真正意义上为类对象的初始化与普通数组和 POD 的初 始化方法提供了统一的桥梁。</p>
<blockquote>
<div><p>Tips：</p>
<ul class="simple">
<li><p>类对象在被列表初始化时会优先调用列表初始化构造函数，如果没有列表初始化构造函数则会根据提供的花括号值调用匹配的构造函数</p></li>
<li><p>C++11新标准提供了两种方法用于处理可变数量形参， 第一种是我们这里提到的<code class="docutils literal notranslate"><span class="pre">initializer_list</span></code>形参（所有的形参类型必须相同），另一种是可变参数模板（可以处理不同类型的形参）</p></li>
</ul>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// 接受初始化列表的构造函数</span>
    <span class="n">Cat</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Cat</span> <span class="n">cat1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初始化列表除了用于对象构造函数上，还可以作为普通参数形参：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">({</span><span class="s">&quot;tomo&quot;</span><span class="p">,</span> <span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="s">&quot;tomocat&quot;</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="永久链接至标题">¶</a></h2>
<p>[1] https://blog.csdn.net/xiongya8888/article/details/89390440</p>
<p>[2] https://my.oschina.net/u/920274/blog/3074998</p>
<p>[3] https://blog.csdn.net/linda_ds/article/details/82807006</p>
<p>[4] https://en.cppreference.com/w/cpp/language/value_initialization</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="%5B%E9%80%89%E8%AF%BB%5DPOD%E7%B1%BB%E5%9E%8B.html" class="btn btn-neutral float-right" title="[选读] POD类型" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="1.6%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html" class="btn btn-neutral float-left" title="1.6 类型转换" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, TOMOCAT.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>